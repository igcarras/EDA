# -*- coding: utf-8 -*-
"""dyv.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1cM1cZ5SYegfb8VJ8k-OmgRjsb_Zgvnsc

<a href="https://colab.research.google.com/github/isegura/EDA/blob/master/dyv.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Divide y Vencerás

## 1) Mayor elemento de un array
"""

def findMax(a: list) -> int:
    """returns the greatest element of A"""
    #A none or A=[]
    if a==None or len(a)==0:
        return None

    #base case
    if len(a)==1:
        return a[0]

    #Recursive case
    #dividir
    m=len(a)//2
    part1=a[0:m]
    part2=a[m:]

    #vencer
    mayor1=findMax(part1) #el mayor del array part1
    mayor2=findMax(part2)  #el mayor del array part2
    #combinar
    return max(mayor1,mayor2)

"""Vemos ahora una solución cuya complejidad espacial es menor, porque no utiliza listas auxiliares para almacenar las sublistas."""

def findMax2(a: list) -> int:
    if a and len(a)>0:
        return _findMax(a, 0, len(a)-1)
    else:
        return None

def _findMax(a: list, start: int, end: int) -> int:
    if start==end:
        return a[start]
    else:
        mid=(start+ end)//2
        max1=_findMax(a, start, mid)
        max2=_findMax(a, mid+1, end)
        return max(max1,max2)

"""Aquí puedes encontrar código para probar las dos funciones anteriores. Ejecutalo varias veces, para probar con distintos tamaños y valores en la lista:"""

import random
#Test 
data=[]
n = random.randint(1, 7)
for i in range(n):
  data.append(random.randint(0,50))

print("The maximum element in {} is {} ".format(data,findMax(data)))  
print("The maximum element in {} is {} ".format(data,findMax2(data)))

# Si no es True, hay algún error
assert max(data) == findMax(data)
# Si no es True, hay algún error
assert max(data) == findMax2(data)

"""## Función que devuelva el mayor y menor elemento de un array 


"""

def findMaxMin(a: list) -> (int, int):
    """función que recibe una lista y devuelve 
    el mayor y menor elemento en la lista"""
    #a none or a=[]
    if a is None or len(a)==0:
        return None, None

    #base case
    if len(a)==1:
        return a[0], a[0] 

    #Recursive case
    #dividir
    m=len(a)//2
    part1=a[0:m]
    part2=a[m:]

    #vencer
    max1, min1=findMaxMin(part1) 
    max2, min2=findMaxMin(part2) 
    
    #combinar
    return max(max1,max2), min(min1,min2)

#Test 
data=[]
for i in range(5):
  data.append(random.randint(0,50))

print("The maximum and minimum elements in {} are {} ".format(data,findMaxMin(data)))  

# Si no es True, hay algún error
assert max(data), min(data) == findMaxMin(data)

"""**Ejercicio: **

Implementa una versión de findMaxMin que tenga una menor computación espacial que la anterior versión. 

"""

def findMaxMin2(a: list) -> (int, int):
    if a and len(a)>0:
        return _findMaxMin2(a, 0, len(a)-1)
    else:
        return None, None

def _findMaxMin2(a: list, start: int, end: int) -> (int, int):
    if start==end:
        return a[start], a[start]
    else:
        mid=(start+ end)//2
        max1, min1=_findMaxMin2(a, start, mid)
        max2, min2=_findMaxMin2(a, mid+1, end)
        return max(max1,max2), min(min1, min2)

#Test 
data=[]
n = random.randint(1,10)
for i in range(n):
  data.append(random.randint(0,50))

print("The maximum and minimum elements in {} are {} ".format(data,findMaxMin2(data)))  

# Si no es True, hay algún error
assert max(data), min(data) == findMaxMin2(data)

"""*Implementa* una función que devuelva **el número par más pequeño** en una lista de Python. Si la lista no contiene valores pares debe devolver None.

"""

def findLowestEvenOdd(a: list) -> (int, int):
    """returns the lowest even and the lowest odd of A"""
    
    if a is None or len(a)==0:
        return None, None

    if len(a)==1:
        if a[0]%2==0:
            return a[0], None
        else:
            return None, a[0]

    #dividir
    m=len(a)//2
    part1=a[0:m]
    part2=a[m:]

    minEven1,minOdd1= findLowestEvenOdd(part1)
    minEven2,minOdd2=findLowestEvenOdd(part2)

    if minEven1 and minEven2:
        minEven = min(minEven1,minEven2)
    elif minEven1 is None and minEven2:
        minEven = minEven2
    elif minEven2 is None and minEven1:
        minEven = minEven1
    else: #los dos son None
        minEven = None

    if minOdd1 and minOdd2:
        minOdd=min(minOdd1,minOdd2)
    elif minOdd1 is None and minOdd2:
        minOdd=minOdd2
    elif minOdd2 is None and minOdd1:
        minOdd=minOdd1
    else: #los dos son None
        minOdd=None
    

    return minEven, minOdd


data = []
n = random.randint(0,10)
for i in range(n):
    x=random.randint(0, 25)
    data.append(x)

print("findLowestEvenOdd({})={}".format(data,findLowestEvenOdd(data)))

"""Implementa una función basada en divide y 
vencerás que **sume los elementos múltiplos de 5 **en una array.

"""

def sumMultiply5(a: list) -> int:
    if a is None or len(a)==0:
        return None, None

    if len(a)==1:
        if a[0]%5==0:
            return a[0]
        else:
            return 0

    m=len(a)//2
    part1=a[0:m]
    part2=a[m:]

    sum1=sumMultiply5(part1)
    sum2=sumMultiply5(part2)
    return sum1+sum2

data = []
n = random.randint(0, 10)
for i in range(n):
    x=random.randint(0, 100)
    data.append(x)


print("sumMultiply5({})={}".format(data, sumMultiply5(data)))

"""## Binary search

Given a **sorted list** and a number, x, return True if x is found, False otherwise.
"""

def binarySearch(a: list, x: int) -> bool:
    """A is a sorted array. 
    It returns True if x is found, False eoc."""
    if a==None:
        return False
        
    #base case
    if len(a)==0:
        return False
    #recursive case
    m=len(a)//2

    if x==a[m]:
        return True

    if x<a[m]:
        return binarySearch(a[0:m],x)

    if x>a[m]:
        return binarySearch(a[m+1:],x)

#Test
data=[1, 4, 38, 39, 40, 61, 69, 71, 81, 87]

x=71 #an element that exists
print("binarySearch({},{})={}\n".format(data, x, binarySearch(data, x)))

#An element that does not exist
x=50
print("binarySearch({},{})={}\n".format(data, x, binarySearch(data, x)))

#we randomly create a list 
data=[]
for i in range(10):
    data.append(random.randint(0,100))
#we sort it
data.sort()


for i in range(5):
    x=random.randint(0,100)
    print("binarySearch({},{})={}\n".format(data,x,binarySearch(data,x)))

"""Implementa una función que reciba un **array  ordenado de enteros** A y un valor x, y **devuelva el índice de x en el array A**. Si x no existe, la función devuelve -1. No está permitido aplicar slicing (es decir, expresiones del tipo A[0:m] o A[m:]) ni crear sublistas auxiliares."""

def binarySearch(a: list, x: int) -> int:
    #base case
    if a is None or len(a)==0:
        return -1
    return _binarySearch(a, x, 0, len(a)-1)

def _binarySearch(a: list, x: int, start: int, end: int) -> int:
    """returns the index of x in a. """
    
    #recursive case

    m = (start+end)//2
    if x==a[m]:
        return m

    if x<a[m]:
        return _binarySearch(a,x,start,m-1)
    if x>a[m]:
        return _binarySearch(a,x,m+1,end)

data=[1,2,3,4,5,6,7,8,9]
x=4 #index=3
print(binarySearch(data,x))
for x in data:
    print(binarySearch(data, x), data.index(x))

"""## Suma de los elementos de un array

Implementa una función que reciba un array de enteros y devuelva su suma (aplicando divide y vencerás).


"""

def sumaArray(a: list) -> int:

    if a is None or len(a)==0:
        return 0
        
    #base case
    if len(a)==1:
        return a[0]

    #recursive case

    #dividir
    m=len(a)//2
    part1=a[0:m]
    part2=a[m:]

    #vencer
    sum1=sumaArray(part1)
    sum2=sumaArray(part2)
    
    #combinar
    return sum1+sum2

data=[]
for i in range(10):
    data.append(random.randint(0,100))

print("sumaArray({})={}".format(data, sumaArray(data)))
assert sum(data) == sumaArray(data)

"""Implementa una función basada en divide y vencerás que reciba una lista de strings y **devuelva una lista con los strings que tengan longitud menor o igual que 2**. 

"""

def getWordsLength2(words: list) -> list:
    if words is None or len(words)==0:
        return []

    if len(words)==1:
        w=words[0]
        if len(w)<=2:
            return [w] 
        else:
            return []

    m=len(words)//2
    part1=words[:m]
    part2=words[m:]

    result1=getWordsLength2(part1)
    result2=getWordsLength2(part2)
    
    return result1+result2

words=["Ha", "llegado", "el", "afilador", "a", "su", "domicilio", "a", "la", "puerta", "de", "su", "casa", "se", "afilan", "cuchillos", "tijeras"]
print("getWordsLength2({})  =\n    {}".format(words,getWordsLength2(words)))

"""Implementa una función basada en divide y vencerás que reciba una lista de strings y que devuelva la **palabra con mayor longitud**. """

def longestWord(words: list) -> str:
    if words is None or len(words)==0:
        return None

    if len(words)==1:
        return words[0]

    m=len(words)//2
    part1=words[:m]
    part2=words[m:]
    
    word1=longestWord(part1)
    word2=longestWord(part2)

    if word1==None and word2==None:
        return None
    elif word1==None:
        return word2
    elif word2==None:
        return word1
    else:
        if len(word1)>=len(word2):
            return word1
        else:
            return word2

A=['ata','mata','atare','vitamina','oz']
print("longestWord({})={}".format(A,longestWord(A)))