# -*- coding: utf-8 -*-
"""mergesort.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tzizegMIGwm5uQv3OaW-GktTxmGIWMq7

<a href="https://colab.research.google.com/github/isegura/EDA/blob/master/mergesort.ipynb" target="_parent"><img src="https://colab.research.google.com/assets/colab-badge.svg" alt="Open In Colab"/></a>

# Mergesort 

En este notebook, presentamos distintas implementaciones del algoritmo mergesort (basado en divide y vencerás). 

## Versión que recibe una lista y devuelve una nueva lista ordenada (de menor a mayor) con los elementos de la lista de entrada

Esta primera versión recibe una lista (de Python) y devuelve la lista ordenada. La lista de entrada no es modificada.
"""

def mergesort(a: list) -> list:
    """devuelve una nueva lista que resulta de ordenar la lista a"""
    if a is None or len(a) <= 1:
        # la lista ya está ordenada
        return a

    middle = len(a) // 2
    part1 = a[0: middle]
    part2 = a[middle: ]
    part1 = mergesort(part1)
    part2 = mergesort(part2)
    return merge(part1, part2)
    
def merge(list1: list, list2: list) -> list: 
    """recibe dos listas ordenadas y devuelve una nueva lista
    que es la mezcla ordenada de las dos listas de entrada"""

    result = []
    i, j = 0, 0
    # mientras que queden elementos en ambas listas
    while i < len(list1) and j < len(list2):
        # copiamos el elemento más pequeño a la nueva lista
        # avanzamos el índice en la sublista correspondiente
        if list1[i] <= list2[j]:
            result.append(list1[i])
            i += 1
        else:
            result.append(list2[j])
            j += 1
    # llegados a este punto, únicamente quedaran elementos
    # en una de las dos listas.
    # copiamos el resto de list1 (si quedaran elementos)
    while i < len(list1):
        result.append(list1[i])
        i += 1
    # copiamos el resto de list2 (si quedaran elementos)
    while j < len(list2):
        result.append(list2[j])
        j += 1   
    # devolvemos la lista 
    return result

"""Probamos con distintas listas creados de forma aleatoria. Debes ejecutarlo varias veces para probarlo con distintos tamaños y distintos valores:"""

import random
a = []
n = random.randint(1, 10)
for _ in range(n):
    x = random.randint(-5,10)
    a.append(x)

print("input: ", a, ", sorted: ", mergesort(a))

# Python’s assert statement allows you to include checks (known as assertions)
# to test if certain assumptions remain true. If any of your assertions turn false, 
# then you have a bug in your code.
assert mergesort(a) == sorted(a)

"""## Función que ordena la lista. 
En la siguiente implementación, la función mergesort recibe una lista y la ordena de menor a mayor. Esta versión no devuelve una nueva lista, sino que modifica la lista que recibe como parámetro de entrada.
"""

def mergesort(a: list) -> None:
    """ordena la lista a"""
    if a is None or len(a) <= 1:
        # la lista ya está ordenada
        return 

    middle = len(a) // 2
    part1 = a[0: middle]
    part2 = a[middle: ]
    mergesort(part1)
    mergesort(part2)
    merge(part1, part2, a)
    
def merge(list1: list, list2: list, result: list) -> None: 
    """la función recibe dos listas ordenadas, list1 y list2, y mezcla ambas
    listas en una lista ordenada que se almacena en la lista result"""
    i, j, k = 0, 0, 0
    while i < len(list1) and j < len(list2):
        if list1[i] <= list2[j]:
            result[k] = list1[i]
            i += 1
        else:
            result[k] = list2[j]
            j += 1
        k += 1

    while i < len(list1):
        result[k] = list1[i]
        i += 1
        k += 1

    while j < len(list2):
        result[k] = list2[j]
        j += 1    
        k += 1

"""Probamos con distintas listas creados de forma aleatoria. Debes ejecutarlo varias veces para probarlo con distintos tamaños y distintos valores:"""

import random
import copy
a = []
n = random.randint(1, 10)
for _ in range(n):
    x = random.randint(-5,10)
    a.append(x)
# creamos una copia por valor de a (no se almacena en la misma dirección)
aux = copy.deepcopy(a)

print("before: ", a, end = ' ')
mergesort(a)
print(", after: ", a)
assert a == sorted(aux)

"""## Versión con menos complejidad espacial

Las dos implementaciones anteriores son correctas y robustas. En ambas implementaciones, al dividir la lista, se crean dos sublistas nuevas. Es posible proponer una solución con una complejidad espacial menor. 

A continuación, vemos una implementación que utiliza indices para especificar las particiones a ordenar en cada llamada recursiva. 
"""

def mergesort(a: list) -> None:
    """ recibe una lista y la ordena de menor a mayor"""
    if a is None or len(a) <= 1:
        return
    _mergesort(a, 0, len(a)-1)

def _mergesort(a: list, start: int, end: int) -> None:
    """ recibe una lista y ordena los elementos entre los índices start y end,
    ambos incluidos """
    # Caso base: si start >= end, significa que la partición tiene 0 o 1 elementos
    # No es necesario hacer nada porque la partición entre [start, end] ya están ordenados
    # Caso general si start < end
    if start < end:
        # calculamos la posición central en [start, end]
        m = (start + end) // 2
        # ordenamos la partición entre los índices [start, m]
        _mergesort(a, start, m)
        # ordenamos la partición entre los índices [m+1, end]
        _mergesort(a, m+1, end)
        # las particiones entre [start, m] y [m+1, end] ya están ordenadas
        # usamos merge para mezclar ambas particiones de forma ordenada
        merge(a, start, end, m)
        # después de esto, la partición [start, end] ya estará ordenada 



def merge(a: list, start: int, end: int, m: int) -> None:
    """los elementos de [start, m] y de [m+1, end] están ordenados.
    Hay que mezclar ambas particiones"""
    i, j = start, m+1
    aux_list = []
    while i <= m and j<= end:
        if a[i] <= a[j]:
            aux_list.append(a[i])
            i += 1
        else:
            aux_list.append(a[j])
            j += 1
        
    while i<=m:
        aux_list.append(a[i])
        i += 1
        
    while j<=end:
        aux_list.append(a[j])
        j += 1

    # move from aux_list to a in the range [start, end]
    for k in range(start, end+1):
        a[k] = aux_list[k - start]

"""Probamos con distintas listas creados de forma aleatoria. Debes ejecutarlo varias veces para probarlo con distintos tamaños y distintos valores:"""

import random
import copy
a = []
n = random.randint(1, 10)
for _ in range(n):
    x = random.randint(-5,10)
    a.append(x)

# crea una copia de a, pero almacenada en una diferente posición de memoria.
aux = copy.deepcopy(a)

print("before: ", a, end = ' ')
mergesort(a)
print(", after: ", a)

assert a == sorted(aux)