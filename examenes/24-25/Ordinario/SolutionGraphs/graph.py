# -*- coding: utf-8 -*-
"""graph-dictionaryWD.ipynb

Automatically generated by Colaboratory.

# Graph implementation using a Python dictionary

This implementation allows to represent any kind of graphs.
"""

class AdjacentVertex:
    """Note: Instead of using this class, you could use a tuple"""

    def __init__(self,vertex,weight):
        self.vertex=vertex
        self.weight=weight
  
    def __str__(self):
        return '('+str(self.vertex)+','+str(self.weight)+')'


class Graph():
    def __init__(self,labels,directed=True):
        """We use a dictionary to represent the graph
        the dictionary's keys are the vertices
        The value associated for a given key will be the list of their neighbours.
        Initially, the list of neighbours is empty"""
        self.vertices={}
        for v in labels:
            self.vertices[v]=[]
        self.directed=directed
    
    def addEdge(self, start, end, weight=0):
        if start not in self.vertices:
            print(start,' does not exist!')
            return
        if end not in self.vertices:
            print(end,' does not exist!')
            return
        
        #adds to the end of the list of neigbours for start
        self.vertices[start].append(AdjacentVertex(end,weight))

        if self.directed==False:
            #adds to the end of the list of neigbours for end
            self.vertices[end].append(AdjacentVertex(start,weight))

    def containsEdge(self, start, end):
        if start not in self.vertices:
            print(start,' does not exist!')
            return -1
        if end not in self.vertices:
            print(end,' does not exist!')
            return -1

        #we search the AdjacentVertex whose v is end
        for adj in self.vertices[start]:
            if adj.vertex==end:
                if adj.weight!=0:
                    return adj.weight
                else:
                    return 1 #unweighted graphs
        return 0  #does not exist

    def removeEdge(self,start,end):
        if start not in self.vertices:
            print(start,' does not exist!')
            return
        if end not in self.vertices:
            print(end,' does not exist!')
            return

        #we must look for the adjacent AdjacentVertex (neighbour)  whose vertex is end, and then remove it
        for adj in self.vertices[start]:
            if adj.vertex==end:
                self.vertices[start].remove(adj)
        if self.directed==False:
            #we must also look for the AdjacentVertex (neighbour)  whose vertex is end, and then remove it
            for adj in self.vertices[end]:
                if adj.vertex==start:
                    self.vertices[end].remove(adj)
  
    def __str__(self):
        result=''
        for v in self.vertices:
            result+='\n'+str(v)+':'
            for adj in self.vertices[v]:
                result+=str(adj)
            
        return result
